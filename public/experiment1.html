<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Water Jug Lab | Pro Command Center</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-app: #f1f5f9;
    --panel-bg: #ffffff;
    --border: #e2e8f0;
    
    /* Brand Colors */
    --primary: #3b82f6;
    --primary-dark: #1d4ed8;
    --accent: #0ea5e9;
    
    /* Terminal Colors */
    --term-bg: #0f172a;
    --term-text: #e2e8f0;
    --term-green: #22c55e;
    --term-blue: #60a5fa;
    --term-red: #f87171;
    --term-yellow: #facc15;
  }

  * { box-sizing: border-box; }

  /* --- SECURITY: PRINT BLOCKING --- */
  @media print {
      html, body { display: none !important; }
  }

  /* --- SECURITY: CONTENT PROTECTION --- */
  body {
    margin: 0;
    font-family: 'Inter', sans-serif;
    background-color: var(--bg-app);
    color: #1e293b;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    user-select: none; /* Prevent text selection */
    -webkit-user-select: none;
  }

  /* --- SECURITY CURTAIN (Anti-Screenshot Overlay) --- */
  #securityCurtain {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: #000; color: #fff; z-index: 10000;
      display: none; align-items: center; justify-content: center;
      text-align: center; flex-direction: column;
  }
  .security-msg { font-family: 'JetBrains Mono', monospace; color: #ef4444; font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem; }
  .security-sub { color: #9ca3af; }
  
  /* Termination State Style */
  #securityCurtain.terminated {
      background: #1a0000;
  }
  #securityCurtain.terminated .security-msg {
      font-size: 3rem;
      text-transform: uppercase;
      animation: flash 1s infinite;
  }
  @keyframes flash { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

  /* --- LOGIN OVERLAY --- */
  #loginOverlay {
    position: fixed; inset: 0;
    background: rgba(15, 23, 42, 0.7);
    backdrop-filter: blur(12px);
    display: flex; align-items: center; justify-content: center;
    z-index: 9999;
  }
  .login-card {
    background: white; padding: 2.5rem; border-radius: 24px;
    width: 100%; max-width: 420px;
    box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
    text-align: center;
  }
  .login-card h2 { margin: 0 0 10px; color: #0f172a; font-weight: 800; letter-spacing: -0.5px; }
  .login-desc { color: #64748b; margin-bottom: 1.5rem; font-size: 0.95rem; }
  
  .form-group { margin-bottom: 1rem; text-align: left; }
  .form-group label { display: block; font-size: 0.8rem; font-weight: 700; color: #475569; margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.5px; }
  .form-input { 
    width: 100%; padding: 0.9rem; border: 2px solid var(--border); 
    border-radius: 12px; font-size: 1rem; transition: all 0.2s;
    background: #f8fafc; font-weight: 500;
  }
  .form-input:focus { outline: none; border-color: var(--primary); background: white; box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.1); }
  
  .login-btn {
    width: 100%; padding: 1rem; background: linear-gradient(135deg, var(--primary), var(--primary-dark)); 
    color: white; border: none; border-radius: 12px; font-weight: 700; cursor: pointer;
    font-size: 1rem; margin-top: 10px; transition: transform 0.1s, box-shadow 0.2s;
    box-shadow: 0 10px 15px -3px rgba(37, 99, 235, 0.3);
  }
  .login-btn:hover { transform: translateY(-2px); box-shadow: 0 15px 20px -3px rgba(37, 99, 235, 0.4); }
  .login-btn:active { transform: scale(0.98); }

  /* --- APP LAYOUT --- */
  .app-container {
    max-width: 1400px; margin: 0 auto; padding: 20px;
    display: flex; flex-direction: column; gap: 15px;
    height: 100%; width: 100%;
  }

  .header-bar {
    display: flex; justify-content: space-between; align-items: center;
    background: var(--panel-bg); padding: 15px 24px;
    border-radius: 16px; border: 1px solid var(--border);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
  }
  .app-title { font-weight: 800; font-size: 1.4rem; background: linear-gradient(to right, var(--primary), var(--accent)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
  .student-badge { background: #f0f9ff; color: #0369a1; padding: 8px 16px; border-radius: 30px; font-size: 0.85rem; font-weight: 700; border: 1px solid #bae6fd; }

  .main-grid {
    display: grid; grid-template-columns: 320px 1fr;
    grid-template-rows: 1fr 220px; gap: 20px; flex: 1; min-height: 0;
  }

  /* --- CONTROLS --- */
  .controls-panel {
    grid-column: 1; grid-row: 1 / span 2;
    background: var(--panel-bg); border-radius: 20px; border: 1px solid var(--border);
    padding: 24px; display: flex; flex-direction: column; gap: 24px;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.03);
  }
  
  .panel-section-title { font-size: 0.75rem; font-weight: 800; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px; }
  
  .task-card { background: #f8fafc; border: 1px solid var(--border); border-radius: 16px; padding: 16px; border-left: 4px solid var(--primary); }
  .task-value { font-size: 1.5rem; font-weight: 800; color: #0f172a; margin: 4px 0; }
  .task-meta { font-size: 0.85rem; color: #64748b; font-weight: 500; }
  
  /* Timer Style */
  .timer-box {
      margin-top: 15px; padding-top: 10px; border-top: 1px solid #e2e8f0;
      display: flex; justify-content: space-between; align-items: center;
  }
  .timer-label { font-size: 0.75rem; font-weight: 700; color: #64748b; text-transform: uppercase; }
  .timer-val { font-family: 'JetBrains Mono'; font-weight: 700; font-size: 1.2rem; color: var(--primary); }

  .btn-grid { display: grid; gap: 12px; }
  button {
    padding: 14px 18px; border-radius: 12px; border: none;
    font-family: 'Inter', sans-serif; font-weight: 600; font-size: 0.95rem;
    cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: space-between;
  }
  .btn-primary { background: var(--primary); color: white; box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.2); }
  .btn-primary:hover { background: var(--primary-dark); transform: translateY(-2px); }
  .btn-secondary { background: white; border: 2px solid var(--border); color: #334155; }
  .btn-secondary:hover { border-color: #cbd5e1; background: #f1f5f9; }
  
  /* Reset Button Styles */
  .btn-danger { background: #fee2e2; color: #dc2626; margin-top: auto; justify-content: center; }
  .btn-danger:hover { background: #fecaca; }
  
  .btn-disabled {
      background: #e2e8f0; color: #94a3b8; cursor: not-allowed;
      box-shadow: none; transform: none !important;
  }

  /* --- CANVAS --- */
  .canvas-panel {
    grid-column: 2; grid-row: 1;
    background: white; border-radius: 20px; border: 1px solid var(--border);
    position: relative; overflow: hidden;
    box-shadow: inset 0 0 60px rgba(0,0,0,0.02);
  }
  canvas { width: 100%; height: 100%; display: block; }

  /* --- TERMINAL --- */
  .terminal-panel {
    grid-column: 2; grid-row: 2;
    background: var(--term-bg); border-radius: 16px; border: 1px solid #334155;
    display: flex; flex-direction: column; overflow: hidden;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
  }
  .term-header {
    background: #1e293b; padding: 10px 20px; border-bottom: 1px solid #334155;
    display: flex; justify-content: space-between; align-items: center;
  }
  .term-title { font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; font-weight: 700; color: #94a3b8; display: flex; align-items: center; gap: 8px; }
  .pulse { width: 8px; height: 8px; background: var(--term-green); border-radius: 50%; box-shadow: 0 0 8px var(--term-green); animation: pulse 2s infinite; }
  @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

  .term-body {
    flex: 1; padding: 16px; font-family: 'JetBrains Mono', monospace; font-size: 0.85rem;
    color: var(--term-text); overflow-y: auto; line-height: 1.6;
  }
  .log-line { display: flex; gap: 12px; margin-bottom: 4px; }
  .ts { color: #475569; min-width: 70px; }
  .msg-sys { color: var(--term-yellow); font-style: italic; }
  .msg-act { color: var(--term-blue); font-weight: 700; }
  .msg-suc { color: var(--term-green); }
  .msg-err { color: var(--term-red); }
  
  .cursor { display: inline-block; width: 8px; height: 16px; background: var(--term-green); vertical-align: sub; animation: blink 1s infinite; }
  @keyframes blink { 50% { opacity: 0; } }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 8px; height: 8px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
  .term-body::-webkit-scrollbar-thumb { background: #334155; }

  @media (max-width: 1024px) {
    .main-grid { grid-template-columns: 1fr; grid-template-rows: auto 450px 200px; }
    .controls-panel { grid-column: 1; grid-row: 2; }
    .canvas-panel { grid-column: 1; grid-row: 1; }
    .terminal-panel { grid-column: 1; grid-row: 3; }
  }
</style>
</head>
<body>

<div id="securityCurtain">
  <div class="icon-lock" style="font-size: 4rem;">ðŸ”’</div>
  <div class="security-msg">CONTENT HIDDEN</div>
  <div class="security-sub">Screenshot Attempt / Window Unfocused</div>
  <div class="security-warning" style="margin-top:20px; color:#facc15; font-weight:bold;"></div>
</div>

<div id="loginOverlay">
  <div class="login-card">
    <h2>Water Jug Lab</h2>
    <p class="login-desc">Enter your credentials to initialize the simulation environment.</p>
    
    <div class="form-group">
      <label>Full Name</label>
      <input id="studentName" class="form-input" placeholder="e.g. Alex Smith" autocomplete="off" />
    </div>

    <div class="form-group">
      <label>Register Number</label>
      <input id="regNo" class="form-input" placeholder="e.g. RA2111003010xxx" autocomplete="off" />
    </div>

    <button id="loginBtn" class="login-btn">Initialize System</button>
  </div>
</div>

<div class="app-container">
  <header class="header-bar">
    <div class="app-title">ðŸ’§ Water Jug Logic Gate</div>
    <div class="student-badge" id="studentDisplay">Not Logged In</div>
  </header>

  <div class="main-grid">
    
    <aside class="controls-panel">
      <div>
        <div class="panel-section-title">Mission Objective</div>
        <div class="task-card">
          <div class="task-meta">Target Volume</div>
          <div class="task-value" id="goalDisplay">--</div>
          <div class="task-meta" id="taskMeta">Waiting for assignment...</div>
          
          <div class="timer-box">
              <span class="timer-label">Elapsed Time</span>
              <span class="timer-val" id="timerDisplay">00:00</span>
          </div>
        </div>
      </div>

      <div>
        <div class="panel-section-title">Control Interface</div>
        <div class="btn-grid">
          <button class="btn-primary" id="fillA"><span>Fill Jug A</span> <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v20M5 13l7 7 7-7"/></svg></button>
          <button class="btn-primary" id="fillB"><span>Fill Jug B</span> <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v20M5 13l7 7 7-7"/></svg></button>
          <button class="btn-secondary" id="pourAtoB"><span>Pour A &rarr; B</span> <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg></button>
          <button class="btn-secondary" id="pourBtoA"><span>Pour B &rarr; A</span> <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg></button>
          <button class="btn-secondary" id="emptyA"><span>Empty A</span> <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg></button>
          <button class="btn-secondary" id="emptyB"><span>Empty B</span> <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg></button>
        </div>
      </div>

      <button class="btn-danger" id="resetBtn">System Reset (3 left)</button>
    </aside>

    <main class="canvas-panel">
      <canvas id="cv" width="1100" height="550"></canvas>
    </main>

    <footer class="terminal-panel">
      <div class="term-header">
        <div class="term-title"><div class="pulse"></div> SYSTEM_LOGS // LIVE</div>
        <div style="font-size:0.7rem; color:#64748b; font-weight:700;">v3.0.PRO</div>
      </div>
      <div class="term-body" id="termBody">
        <div class="log-line"><span class="ts">SYS</span><span class="msg-sys">Initializing graphics engine... OK</span></div>
        <div class="log-line"><span class="ts">SYS</span><span class="msg-sys">Waiting for user credentials...</span></div>
        <div id="termCursor" class="cursor"></div>
      </div>
    </footer>

  </div>
</div>

<script>
/* =========================================================
   1) CONFIG & UTILS
========================================================= */
const TASKS = [
  { stageId:"S1", capA:5, capB:3, mode:"single", targetSingle:1 },
  { stageId:"S2", capA:4, capB:3, mode:"single", targetSingle:2 },
  { stageId:"S3", capA:7, capB:4, mode:"single", targetSingle:3 },
  { stageId:"D1", capA:3, capB:5, mode:"double", targetA:3, targetB:4 },
  { stageId:"D2", capA:6, capB:4, mode:"double", targetA:2, targetB:4 },
  { stageId:"D3", capA:8, capB:5, mode:"double", targetA:6, targetB:1 },
];

function hashSeed(str){
  let h = 0; for(let i=0;i<str.length;i++) h = (h*31 + str.charCodeAt(i)) >>> 0;
  return h;
}
function assignTaskForStudent(regNo){
  return TASKS[hashSeed(String(regNo)) % TASKS.length];
}
function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }

// --- TERMINAL LOGGING ---
const termBody = document.getElementById("termBody");
const termCursor = document.getElementById("termCursor");

function logTerm(msg, type="info") {
  const timeStr = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute:'2-digit', second:'2-digit' });
  const line = document.createElement("div");
  line.className = "log-line";
  
  let cls = "msg-info";
  if(type==="action") cls="msg-act";
  if(type==="success") cls="msg-suc";
  if(type==="error") cls="msg-err";
  if(type==="system") cls="msg-sys";

  line.innerHTML = `<span class="ts">[${timeStr}]</span><span class="${cls}">${msg}</span>`;
  termBody.insertBefore(line, termCursor);
  termBody.scrollTop = termBody.scrollHeight;
}

/* =========================================================
   2) STATE MANAGEMENT
========================================================= */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");

let student = { name:"", regNo:"" };
let isSessionActive = false; // Controls when security features start
let assignedTask = null;
let capA = 5, capB = 3;
let mode = "single", targetSingle = 1, targetA = 3, targetB = 4;
let A = 0, B = 0;
let dispA = 0, dispB = 0;
let busy = false;
let currentActionText = "Ready";
let drops = [];
let bubbles = [];
let wavePhase = 0; // For water animation
let splash = 0;
let attemptStarted = false;
let startTimeMs = 0;
let endTimeMs = 0;
let stepsCount = 0;
let submitted = false;
let timerInterval = null;

// Trackers
let tabSwitchCount = 0;
let screenshotCount = 0;
let resetCount = 0;
const MAX_RESETS = 3;
const MAX_VIOLATIONS = 2; // 3rd strike = out
let isTerminated = false;

// Scene Geometry
const scene = {
  tapX: 160, tapY: 100,
  jugAY: 220, jugBY: 220,
  jugW: 130, jugH: 260,
  jugAX: 300, jugBX: 600,
  puddleX: 225, puddleY: 500
};

/* =========================================================
   3) BACKEND CONNECTION (UPDATED)
========================================================= */
async function saveToBackend(status) {
    if(submitted && status === "COMPLETED") return; // Don't submit success twice
    submitted = true;

    // Get final time string
    const now = Date.now();
    const diff = Math.floor((now - startTimeMs) / 1000);
    const m = Math.floor(diff / 60).toString().padStart(2, '0');
    const s = (diff % 60).toString().padStart(2, '0');
    const timeStr = `${m}:${s}`;

    const payload = {
        studentName: student.name,
        regNo: student.regNo,
        timeTaken: timeStr,
        tabSwitches: tabSwitchCount,
        screenShots: screenshotCount,
        status: status // "COMPLETED" or "TERMINATED"
    };

    logTerm(`Syncing ${status} data to database...`, "system");

    try {
        const response = await fetch('https://nural-network-ml.onrender.com/api/save-log', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        
        if(response.ok) {
            logTerm("Data saved successfully.", "success");
        } else {
            logTerm("Error saving data to server.", "error");
        }
    } catch(e) {
        console.error(e);
        logTerm("Network connection failed.", "error");
    }
}

/* =========================================================
   4) GAME LOGIC
========================================================= */
function updateUI(){
  const goalEl = document.getElementById("goalDisplay");
  const metaEl = document.getElementById("taskMeta");
  
  if(mode === "single"){
    goalEl.innerHTML = `<span style="color:var(--primary)">${targetSingle} Litres</span>`;
    metaEl.innerText = `Using Jug A (${capA}L) & Jug B (${capB}L)`;
  } else {
    goalEl.innerHTML = `<span style="color:var(--primary)">(${targetA}L, ${targetB}L)</span>`;
    metaEl.innerText = `Using Jug A (${capA}L) & Jug B (${capB}L)`;
  }
}

function isGoal(a,b){
  if(mode === "single") return a === targetSingle || b === targetSingle;
  return a === targetA && b === targetB;
}

function updateTimerDisplay(){
    const now = Date.now();
    const diff = Math.floor((now - startTimeMs) / 1000);
    const m = Math.floor(diff / 60).toString().padStart(2, '0');
    const s = (diff % 60).toString().padStart(2, '0');
    document.getElementById('timerDisplay').innerText = `${m}:${s}`;
}

function startAttemptIfNeeded(){
  if(!attemptStarted && !isTerminated){
    attemptStarted = true;
    startTimeMs = Date.now();
    logTerm("Session Timer Started.", "system");
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(updateTimerDisplay, 1000);
  }
}

// --- ANIMATION SYSTEM ---
function spawnParticles(x, y, type="drop"){
  for(let i=0; i<(type==="drop"?12:3); i++){
    if(type==="drop"){
      drops.push({
        x: x + (Math.random()*16-8), y: y + (Math.random()*8-4),
        vx: (Math.random()*2-1)*0.8, vy: 1.8 + Math.random()*1.6, life: 30 + Math.random()*20,
        type: 'drop'
      });
    } else if (type==="bubble"){
      bubbles.push({
        x: x + (Math.random()*scene.jugW - scene.jugW/2), y: y,
        vx: (Math.random()-0.5)*0.5, vy: -(1 + Math.random()), life: 60,
        size: 2 + Math.random()*3
      });
    }
  }
  if(type==="drop") splash = 1;
}

function animateTo(newA, newB, actionText, kind){
  busy = true;
  currentActionText = actionText;
  const startA_ = dispA, startB_ = dispB;
  const duration = (kind.startsWith("pour") ? 50 : 35); // frames
  let t = 0;

  logTerm(`Action: ${actionText}`, "action");

  // Determine stream coordinates for drawing
  const isPour = (kind === "pourAtoB" || kind === "pourBtoA");
  const streamTo = (kind === "pourAtoB") ? {x: scene.jugBX + scene.jugW/2, y: scene.jugBY + 40} 
                 : {x: scene.jugAX + scene.jugW/2, y: scene.jugAY + 40};

  function step(){
    t++;
    // Ease-in-out function for smooth liquid level change
    const p = t/duration;
    const e = p<0.5 ? 2*p*p : 1 - Math.pow(-2*p+2,2)/2;

    dispA = startA_ + (newA - startA_)*e;
    dispB = startB_ + (newB - startB_)*e;

    // Particle Effects during animation
    if(isPour && t % 5 === 0) spawnParticles(streamTo.x, streamTo.y + 200, "drop");
    if((kind==="fillA" || kind==="fillB") && t % 4 === 0) spawnParticles(scene.puddleX, scene.puddleY, "drop");
    
    // Bubble effects rising in jug
    if(t % 6 === 0) {
      if(newA > startA_) spawnParticles(scene.jugAX + scene.jugW/2, scene.jugAY + scene.jugH, "bubble");
      if(newB > startB_) spawnParticles(scene.jugBX + scene.jugW/2, scene.jugBY + scene.jugH, "bubble");
    }

    if(t < duration){
      requestAnimationFrame(step);
    } else {
      dispA = newA; dispB = newB;
      A = newA; B = newB;
      busy = false;
      logTerm(`State: A=${A}L, B=${B}L`, "info");

      if(isGoal(A,B) && attemptStarted && endTimeMs===0 && !isTerminated){
        endTimeMs = Date.now();
        clearInterval(timerInterval); // Stop Timer on Success
        const sec = Math.round((endTimeMs-startTimeMs)/1000);
        logTerm(`SUCCESS! Task Completed in ${sec}s.`, "success");
        saveToBackend("COMPLETED");
      }
    }
  }
  requestAnimationFrame(step);
}

// --- BUTTON LISTENERS ---
document.getElementById("fillA").onclick = () => { if(busy || isTerminated) return; startAttemptIfNeeded(); stepsCount++; animateTo(capA, B, "Fill Jug A", "fillA"); };
document.getElementById("fillB").onclick = () => { if(busy || isTerminated) return; startAttemptIfNeeded(); stepsCount++; animateTo(A, capB, "Fill Jug B", "fillB"); };
document.getElementById("emptyA").onclick = () => { if(busy || isTerminated) return; startAttemptIfNeeded(); stepsCount++; animateTo(0, B, "Empty Jug A", "emptyA"); };
document.getElementById("emptyB").onclick = () => { if(busy || isTerminated) return; startAttemptIfNeeded(); stepsCount++; animateTo(A, 0, "Empty Jug B", "emptyB"); };
document.getElementById("pourAtoB").onclick = () => { if(busy || isTerminated) return; startAttemptIfNeeded(); stepsCount++; const d = Math.min(A, capB - B); animateTo(A-d, B+d, `Pour A -> B (${d}L)`, "pourAtoB"); };
document.getElementById("pourBtoA").onclick = () => { if(busy || isTerminated) return; startAttemptIfNeeded(); stepsCount++; const d = Math.min(B, capA - A); animateTo(A+d, B-d, `Pour B -> A (${d}L)`, "pourBtoA"); };

// MODIFIED RESET BUTTON LOGIC
document.getElementById("resetBtn").onclick = () => { 
  if(busy || isTerminated) return;
  const btn = document.getElementById("resetBtn");
  
  // Check Limits
  if(resetCount >= MAX_RESETS) return;

  resetCount++;
  const resetsLeft = MAX_RESETS - resetCount;
  
  // Update Button Text
  if(resetsLeft > 0) {
      btn.innerText = `System Reset (${resetsLeft} left)`;
  } else {
      btn.innerText = `Reset Limit Reached`;
      btn.classList.add("btn-disabled");
      btn.disabled = true; // Hard disable
  }

  // Log to terminal
  logTerm(`RESET: Attempt ${resetCount}/${MAX_RESETS}`, "error");

  // Perform Reset Logic
  clearInterval(timerInterval);
  document.getElementById('timerDisplay').innerText = "00:00";
  attemptStarted=false; startTimeMs=0; endTimeMs=0; stepsCount=0; submitted=false;
  animateTo(0, 0, "Reset", "reset"); 
};

/* =========================================================
   5) GRAPHICS ENGINE (CANVAS)
========================================================= */
function draw() {
  // Clear & Background
  const grad = ctx.createLinearGradient(0, 0, 0, cv.height);
  grad.addColorStop(0, "#ffffff");
  grad.addColorStop(1, "#f8fafc");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, cv.width, cv.height);

  // Draw Background Grid
  ctx.strokeStyle = "#e2e8f0"; ctx.lineWidth = 1;
  for(let x=0; x<cv.width; x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
  for(let y=0; y<cv.height; y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }

  // Animate Wave
  wavePhase += 0.1;

  // Draw Elements
  drawMetallicTap();
  drawPuddle();
  drawPourStreams();

  const targetLineA = (mode==="double") ? targetA : (targetSingle<=capA ? targetSingle : null);
  const targetLineB = (mode==="double") ? targetB : (targetSingle<=capB ? targetSingle : null);

  drawGlassJug(scene.jugAX, scene.jugAY, scene.jugW, scene.jugH, capA, clamp(dispA,0,capA), "Jug A", targetLineA);
  drawGlassJug(scene.jugBX, scene.jugBY, scene.jugW, scene.jugH, capB, clamp(dispB,0,capB), "Jug B", targetLineB);

  // Particles
  updateAndDrawParticles();
  drawGoalOverlay();

  requestAnimationFrame(draw);
}

function drawMetallicTap(){
  ctx.save();
  ctx.translate(scene.tapX, scene.tapY);
  const pipeGrad = ctx.createLinearGradient(0, -20, 0, 20);
  pipeGrad.addColorStop(0, "#64748b"); pipeGrad.addColorStop(0.5, "#cbd5e1"); pipeGrad.addColorStop(1, "#475569");
  ctx.fillStyle = pipeGrad; ctx.beginPath(); ctx.roundRect(-60, -15, 100, 30, 4); ctx.fill();
  ctx.beginPath(); ctx.moveTo(40, -15); ctx.quadraticCurveTo(80, -15, 80, 20); ctx.lineTo(80, 60); ctx.lineTo(50, 60);
  ctx.lineTo(50, 20); ctx.quadraticCurveTo(50, 15, 40, 15); ctx.fill();
  ctx.fillStyle = "#334155"; ctx.fillRect(50, 60, 30, 8);
  ctx.fillStyle = "#1e293b"; ctx.beginPath(); ctx.roundRect(-20, -35, 40, 10, 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(0, -40, 25, 8, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = "rgba(255,255,255,0.4)"; ctx.beginPath(); ctx.ellipse(0, -42, 18, 3, 0, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawGlassJug(x, y, w, h, cap, amount, label, targetLine){
  ctx.save(); ctx.translate(x, y);
  ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, h - 20); ctx.quadraticCurveTo(0, h, 20, h);
  ctx.lineTo(w - 20, h); ctx.quadraticCurveTo(w, h, w, h - 20); ctx.lineTo(w, 0);
  ctx.fillStyle = "rgba(255, 255, 255, 0.2)"; ctx.fill();
  if(amount > 0.05){
    const waterHeight = (amount / cap) * h; const waterY = h - waterHeight;
    ctx.save(); ctx.clip();
    const liqGrad = ctx.createLinearGradient(0, waterY, 0, h);
    liqGrad.addColorStop(0, "rgba(59, 130, 246, 0.7)"); liqGrad.addColorStop(1, "rgba(37, 99, 235, 0.9)");
    ctx.fillStyle = liqGrad;
    ctx.beginPath(); ctx.moveTo(0, h); ctx.lineTo(0, waterY);
    for (let i = 0; i <= w; i+=5) ctx.lineTo(i, waterY + Math.sin((i/20) + wavePhase) * 3);
    ctx.lineTo(w, h); ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,0.3)";
    bubbles.forEach(b => { if(b.x > x && b.x < x+w && b.y > y+waterY && b.y < y+h){ ctx.beginPath(); ctx.arc(b.x-x, b.y-y, b.size, 0, Math.PI*2); ctx.fill(); }});
    ctx.restore();
  }
  if(targetLine !== null){
    const ty = h - (targetLine/cap)*h;
    ctx.strokeStyle = "#ef4444"; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
    ctx.beginPath(); ctx.moveTo(-10, ty); ctx.lineTo(w+10, ty); ctx.stroke();
    ctx.setLineDash([]); ctx.fillStyle = "#ef4444"; ctx.font = "bold 12px Inter"; ctx.fillText("TARGET", w+12, ty+4);
  }
  ctx.lineWidth = 4; ctx.strokeStyle = "rgba(148, 163, 184, 0.6)"; ctx.stroke();
  ctx.fillStyle = "#64748b"; ctx.font = "10px Inter";
  for(let i=1; i<=cap; i++){ const ly = h - (i/cap)*h; ctx.fillRect(w-10, ly, 10, 2); if(cap < 10 || i%2===0) ctx.fillText(i+"L", w-25, ly+4); }
  ctx.fillStyle = "#0f172a"; ctx.textAlign = "center"; ctx.font = "700 16px Inter"; ctx.fillText(label, w/2, h + 30);
  ctx.font = "800 28px Inter"; ctx.fillText(Math.round(amount)+"L", w/2, h/2);
  ctx.restore();
}

function drawPourStreams(){
  const tapFill = (currentActionText.includes("Fill Jug A") || currentActionText.includes("Fill Jug B")) && busy;
  if(tapFill){
    ctx.beginPath(); ctx.moveTo(scene.tapX + 65, scene.tapY + 60);
    const targetX = currentActionText.includes("Jug A") ? scene.jugAX + scene.jugW/2 : scene.jugBX + scene.jugW/2;
    const targetY = currentActionText.includes("Jug A") ? scene.jugAY + 20 : scene.jugBY + 20;
    const wiggle = Math.sin(wavePhase*3) * 2;
    ctx.quadraticCurveTo(scene.tapX + 65, scene.tapY + 150, targetX + wiggle, targetY);
    ctx.lineWidth = 12; ctx.strokeStyle = "rgba(59, 130, 246, 0.6)"; ctx.lineCap = "round"; ctx.stroke();
  }
  if(busy && (currentActionText.includes("Pour"))){
    const isAtoB = currentActionText.includes("A -> B");
    const startX = isAtoB ? scene.jugAX + scene.jugW : scene.jugBX;
    const startY = isAtoB ? scene.jugAY + 30 : scene.jugBY + 30;
    const endX = isAtoB ? scene.jugBX + 20 : scene.jugAX + scene.jugW - 20;
    const endY = isAtoB ? scene.jugBY + 100 : scene.jugAY + 100;
    ctx.beginPath(); ctx.moveTo(startX, startY);
    const cpX = (startX + endX) / 2; const cpY = startY - 100; 
    ctx.quadraticCurveTo(cpX, cpY, endX, endY);
    ctx.lineWidth = 10; ctx.strokeStyle = "rgba(59, 130, 246, 0.7)"; ctx.stroke();
  }
}

function updateAndDrawParticles(){
  ctx.fillStyle = "#3b82f6";
  for(let i=drops.length-1; i>=0; i--){
    let d = drops[i]; d.x += d.vx; d.y += d.vy; d.vy += 0.2; d.life--;
    if(d.life <= 0) { drops.splice(i, 1); continue; }
    ctx.beginPath(); ctx.arc(d.x, d.y, 3, 0, Math.PI*2); ctx.fill();
  }
  for(let i=bubbles.length-1; i>=0; i--){
    let b = bubbles[i]; b.y += b.vy; b.x += Math.sin(wavePhase + b.y/10)*0.5; b.life--;
    if(b.life <= 0) { bubbles.splice(i, 1); continue; }
  }
}

function drawPuddle(){
  if(splash > 0){
    ctx.save(); ctx.translate(scene.puddleX, scene.puddleY);
    ctx.scale(1 + Math.sin(wavePhase)*0.1, 1);
    ctx.fillStyle = "rgba(147, 197, 253, 0.4)";
    ctx.beginPath(); ctx.ellipse(0, 0, 80 * splash, 15, 0, 0, Math.PI*2); ctx.fill();
    splash -= 0.02; ctx.restore();
  }
}

function drawGoalOverlay(){
  if(isGoal(A,B)){
    ctx.save(); ctx.translate(scene.jugBX + 220, scene.jugBY + 50); ctx.rotate(-0.2);
    ctx.beginPath(); ctx.roundRect(-100, -40, 200, 80, 10);
    ctx.lineWidth = 6; ctx.strokeStyle = "#16a34a"; ctx.stroke();
    ctx.fillStyle = "rgba(220, 252, 231, 0.9)"; ctx.fill();
    ctx.fillStyle = "#15803d"; ctx.font = "900 36px Inter"; ctx.textAlign = "center"; ctx.fillText("SUCCESS", 0, 10);
    ctx.restore();
  }
}

/* =========================================================
   6) LOGIN
========================================================= */
document.getElementById("loginBtn").onclick = () => {
  const n = document.getElementById("studentName").value.trim();
  const r = document.getElementById("regNo").value.trim();
  if(!n || !r){ alert("Credentials required."); return; }
  student = { name:n, regNo:r };
  
  // Set Session as Active for Security Features
  isSessionActive = true; 

  document.getElementById("studentDisplay").innerText = `${n} (${r})`;
  assignedTask = assignTaskForStudent(r);
  capA = assignedTask.capA; capB = assignedTask.capB; mode = assignedTask.mode;
  if(mode === "single") targetSingle = assignedTask.targetSingle;
  else { targetA = assignedTask.targetA; targetB = assignedTask.targetB; }
  logTerm(`User: ${n}`, "success"); logTerm(`Task: ${assignedTask.stageId} loaded.`, "info");
  updateUI();
  document.getElementById("loginOverlay").style.display = "none";
  
  // Log Security Activation
  logTerm("Proctoring Protocol Engaged.", "system");
};

/* =========================================================
   7) PROCTORING & BACKEND CONNECTION
========================================================= */
const curtain = document.getElementById("securityCurtain");
const curtainMsg = curtain.querySelector('.security-msg');
const curtainSub = curtain.querySelector('.security-sub');
const curtainWarn = curtain.querySelector('.security-warning');

function activateCurtain() { if (isTerminated) return; curtain.style.display = 'flex'; document.body.style.overflow = 'hidden'; }
function deactivateCurtain() { if (isTerminated) return; curtain.style.display = 'none'; document.body.style.overflow = 'auto'; }

function terminateSession() {
    isTerminated = true;
    clearInterval(timerInterval);
    curtain.style.display = 'flex'; curtain.classList.add('terminated');
    curtainMsg.innerText = "SESSION TERMINATED";
    curtainSub.innerText = "Maximum security violations exceeded.";
    curtainWarn.innerText = "Contact Administrator.";
    document.body.style.overflow = 'hidden';
    logTerm("FATAL: Session Terminated due to Security Violations.", "error");
    saveToBackend("TERMINATED");
}

function handleViolation(type) {
    if (!isSessionActive || isTerminated) return; // Only process if logged in
    
    // Increment specific counters
    if(type === 'tab') tabSwitchCount++;
    if(type === 'screen') screenshotCount++;
    
    const totalViolations = tabSwitchCount + screenshotCount;
    const attemptsLeft = (MAX_VIOLATIONS + 1) - totalViolations;

    logTerm(`SECURITY ALERT: ${type === 'tab' ? 'Tab Switch' : 'Screenshot'}. Strike ${totalViolations}/${MAX_VIOLATIONS + 1}`, "error");

    if (totalViolations > MAX_VIOLATIONS) {
        terminateSession();
    } else {
        activateCurtain();
        const warningMsg = `Warning! ${type === 'tab' ? 'Tab Switched' : 'Screenshot detected'}. You have ${attemptsLeft} chance(s) remaining.`;
        curtainWarn.innerText = warningMsg;
        alert(warningMsg);
    }
}

// 1. Tab Switching
document.addEventListener("visibilitychange", () => {
  if (!isSessionActive) return; // Skip if not logged in
  if (document.hidden) handleViolation('tab');
  else if(!isTerminated) { logTerm("User returned.", "info"); deactivateCurtain(); }
});

// 2. Window Blur
window.addEventListener('blur', () => { 
  if (!isSessionActive) return; // Skip if not logged in
  if(!document.hidden) handleViolation('tab'); 
});
window.addEventListener('focus', () => { 
  if(!isTerminated) deactivateCurtain(); 
});

// 3. Screenshot Keys
let keysPressed = {};
window.addEventListener('keydown', (event) => {
    if (!isSessionActive || isTerminated) return; // Skip if not logged in
    keysPressed[event.key] = true;
    if (event.key === 'PrintScreen') { handleViolation("screen"); navigator.clipboard.writeText('Blocked'); }
    if ((keysPressed['Meta'] || keysPressed['Control']) && keysPressed['Shift'] && (keysPressed['s'] || keysPressed['S'] || keysPressed['3'] || keysPressed['4'])) {
         handleViolation("screen"); navigator.clipboard.writeText('Blocked'); return false;
    }
});
window.addEventListener('keyup', (event) => { delete keysPressed[event.key]; });

// 4. Disable Context Menu
window.addEventListener('contextmenu', (e) => { 
    if (!isSessionActive) return; // Allow context menu before login if needed (or just always block)
    e.preventDefault(); 
    return false; 
});

// Start Animation
requestAnimationFrame(draw);
</script>
</body>
</html>